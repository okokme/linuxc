#### [数据结构]之查找

若要在某个表中查找出特定的元素，要根据某种特定的结构来查找表，而不同的结构会产生不同的查找方法：

###### 一、比较式查找算法

（1）基于线性表的查找。如：顺序查找、折半查找、分块查找等；

（2）基于树的查找。如：二叉排序树、B树、AVL树等。

这类查找算法的性能主要是通过平均查找长度来评价的。

平均查找长度：为确定某元素在查找表中的位置需要和给定值进行比较的关键字个数的期望值，成为该查找算法查找成功时的平均查找长度（Average Search Length）。

对于长度为n的查找表，查找成功时的平均查找长度为ASL = ∑i=(1 ～n) PiCi

其中Pi为查找表中第i个记录的概率

Ci为找到该记录时，曾经和给定值比较过的关键字的个数。

###### 二、散列法

也叫哈希法、杂凑法、关键字地址法等。

为了做到零次比较，即不需要进行关键字间的比较就完成查找过程。



##### 基于线性表的查找

###### 顺序查找

对于一个无序的，即关键字没有排序的线性表来说，用所给关键字与线性表中的所有记录逐个进行比较，直到成功或失败。

顺序查找表的数据类型描述为：

```c
//顺序查找表的数据类型描述为：
define MAXSIZE 1000 //顺序查找表记录数目
typedef int KeyType; //假设关键字类型为整型
typedef struct
{
    KeyType key; //关键字项
    OtherType other_data; //其他数据项，类型OtherType依赖于具体定义
}RecordType； //记录类型
typedef struct
{
    RecordType r[MAXSIZE+1]l
    int length; //序列长度，即实际记录长度
}SeqRList; //记录序列类型，即顺序表类型
SeqRList L； //L为一个顺序查找表
```

顺序查找：

```c
//顺序查找
int SeqSearch(SeqRList L, KeyType k)
{
    i = L.length;
    while(i>=1 && L.r[i].key != k)
  		i--;
    if(i>=1)	return (i);
    else	return 0;
}
```



加监视哨的顺序查找：

 ```c
//加监视哨的顺序查找
int SeqSearch(SeqRList L, KeyType k)
{
    L.r[0].key = k; //监视哨
    int i = L.length;
    while(L.r[i],key != k)
        i--;
    return(i);
}
 ```

算法利用了0号位置作为监视哨，记录待查记录的关键字，这样从后往前进行查找时，省去了边界条件的判断，无论查找成功还是查找失败，都能找到该条记录在查找表中的位置。如果是i>0位置则查找成功，否则查找失败。

查找成功时平均查找长度是表长的一半，若是一段很长的序列则效率低

优势：对于表的特性没有要求，数据元素可以任意排列，插入元素可以直接插入到表尾。

###### 折半查找

   也叫二分查找，是针对于**有序表**，思想为：先确定待查目标所在的范围，然后逐步缩小范围直到找到或找不到为止。

基本思想：每次将待查范围中间位置上的数据元素的关键字与给定值k进行比较。若相等，查找成功，否则利用该位置将整个表分成前、后两个子表，若中间位置记录的关键字大于待查关键字，则继续在前半部分子表查找，否则就在后半部分子表中进行查找，重复此过程，直到”查找成功“，或“查找不成功”。

折半查找的非递归实现：

```c
//折半查找的非递归实现
int BinSrch(SeqRList L, KeyType K)
{
    int low = 1;
    int high = L.length;
    int mid;
    while(low <= high)
    {
        mid = (low+high)/2;
        if(k == L.r[mid].key)	return mid;
        else if(k<r[mid].key)	high = mid-1;
        else	low = high+1; 
    }
    retutn 0;
}
```

折半查找的递归实现：

```c
//折半查找的递归实现
int BinSrch(int r[], int low, int high, KeyType k)
{
    if(low>high) return -1;
    int mid = (low+high)/2;
    if(k == r[mid])	
        return mid;
    else if(k > r[mid])	
        BinSrch(r,mid+1, high, k);
    else
        BinSrch(r, low, mid-1, k);
    
}
```

折半查找的过程可以用一棵二叉判定树来进行分析，判定树中每一个节点对应表中一个记录，但节点的值不是该记录的关键字，而是记录在表中的位置序号。根节点对应当前区间的中间位置的记录，左子树对应前半部分子表，右子树对应后半部分子表。

显然，找到有序表中任一记录的过程，就是在判定树中从根节点到该记录相应的节点的路径，而**经过比较的次数恰好为该节点在判定树上的层次数**。

![1544625485700](/tmp/1544625485700.png)











