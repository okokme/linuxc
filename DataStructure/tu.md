图，非空。

图中任意两个顶点 vi、vj∈E，vi、vj都是连通的，则称G是连通图。

**连通图--对应无向图**

**强连通图--对应于有向图**

**生成树**：包含连通图中全部顶点的极小连通子图成为该图的生成树。（划重点！！是连通图！！）。

即假设有一个连通图有n个顶点e条边，其中n个顶点和n-1条边构成了一个极小连通子图，该极小连通子图为此连通图的生成树。对于非连通图，由各个连通分量的生成树构成的集合称为该非连通图的生成森林。

##### 连通分量

* 要是子图；

* 子图要是连通的；

* 连通子图含有极大顶点数；

* 具有极大顶点数的连通子图包含依附于这些顶点的所有边。

  ```c
  
  typedef char VetexType; //顶点类型由用户定义
  
  typedef int EdgeType; //边上的权值类型应由用户定义
  
  #define MAXVEX 100 //最大顶点数，应由用户定义
  
  #define INFINITY 65535 
  
  typefed struct
  
  {
  
  	VertexType vexs[MAXVEX]; //顶点表
  
  	EdgeType arcMAXVEX
  
  }
  
  ```

  

typedef char VetexType; //顶点类型由用户定义

typedef int EdgeType; //边上的权值类型应由用户定义

#define MAXVEX 100 //最大顶点数，应由用户定义

#define INFINITY 65535 

typefed struct

{

​	VertexType vexs[MAXVEX]; //顶点表

​	EdgeType arc[MAXVEX][MAXVEX]

}



## 一些关于图的问题：

##### 1.一个具有n个顶点的有向图中，要连通全部顶点至少需要（n）条弧。

疑问：为什么不是n-1条？

（划重点！！有向图！！）

（之前的误区在于认为此图是一个有向图而只需n-1条弧就可以连通![之前的误区在于认为](/home/k/Pictures/tu.png)）

解释：这里的有向图，应该指的是强连通有向图。

强连通有向图，满足两个条件：

（1）没有孤点

（2）任何两点A、B至少存在一条路径。两个点A、B。从A->B存在一条路径，从B->A也存在一条路径。

所以

![](/home/k/Pictures/tu2.png)

形成闭环才叫有向图中能连通全部顶点的最小的弧数。



##### 2.如果含n个顶点的图形形成一个环，则它有（n）棵生成树。

解释：n个顶点形成的环有n条边，若得到生成树只需要删除这n条边中的任意一条即可，所以得到n棵生成树。



##### 3.迪杰斯特拉算法是按路径程度递增的次序产生最短路径的思路求解

![](/home/k/Pictures/djstl.png)



