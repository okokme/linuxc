### C++函数重载

C++函数重载是怎么实现的呢 具体分为一下两个问题

* 声明/定义重载函数时，是如何解决命名冲突的？
* 当我们调用一个重载的函数时，又是如何去解析的？

本篇文章的主要内容如下：

* ##### 例子引入（现象）

​           什么是重载函数（what）？

​           为什么需要函数重载（why）？

* ##### 编译器如何解决命名冲突的

​            函数重载为什么步考虑返回值类型

* ##### 重载函数的调用与搭配

  ​     模棱两可的情况

* ##### 编译器是如何解析重载调用函数的

  ​       根据函数名确定候选函数集

  ​	确定可用函数

  ​	确定最佳搭配函数

#### 1.1什么是函数重载（what）

函数重载是指在**同一作用域内**，可以有一组具**有相同函数名**，**不同参数列表**的函数，这组函数被称为重载函数。重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。

例子：（实现一个打印函数，既可以打印int型、也可以打印字符串型，在C++中）

```C++
#include<iostream>
using namespace std;
void print(int i)
{
    cout<<"print a integer"<<i<<endl;
}
void print(string str)
{
    cout<<"print a string"<<str<<endl;
}
int main()
{
    print(12);
    print("hello world!");
    return 0;
}
通过上边的代码实现，可以提供具体的print()的参数去调用print(int)还是print(string).上面print(12)会去调用print(int),print("hello world")会去调用print(string)
```

#### 1.2为什么需要函数重载（why）？

* 试想如果没有函数重载机制，如在C中，你必须这样去做：为这个print函数取不同的名字，如print_int、print_string.这里还是两个的情况，如果是很多个的情况的话，那可不就是为了实现同一个函数功能取了很多个名字，这样很不友好。
* 类的构造函数跟类名相同，也就是说：构造函数都同名。如果没有函数重载机制，要想实例化不同的对象，很麻烦。
* 操作符重载，本质上就是函数重载，它大大丰富了已有操作符的含义，方便使用，如+可用于连接字符串等。



#### 2.编译器如何解决命名冲突的

重载函数编译后映射到了不同的标识

映射机制为：**作用域**+**返回类型**+**函数名**+**参数列表**

#### **3、重载函数的调用匹配**

现在已经解决了重载函数命名冲突的问题，在定义完重载函数之后，用函数名调用的时候是如何去解析的？为了估计哪个重载函数最适合，需要依次按照下列规则来判断：

- **精确匹配**：参数匹配而不做转换，或者只是做微不足道的转换，如数组名到指针、函数名到指向函数的指针、T到const T；
- **提升匹配**：即整数提升（如bool 到 int、char到int、short 到int），float到double
- **使用标准转换匹配**：如int 到double、double到int、double到long double、Derived*到Base*、T*到void*、int到unsigned int；
- **使用用户自定义匹配**；
- **使用省略号匹配**：类似printf中省略号参数

如果在最高层有多个匹配函数找到，调用将被拒绝（因为有歧义、模凌两可）。

#### **4、编译器是如何解析重载函数调用的？**

编译器实现调用重载函数解析机制的时候，肯定是首先找出同名的一些候选函数，然后从候选函数中找出最符合的，如果找不到就报错。下面介绍一种重载函数解析的方法：编译器在对重载函数调用进行处理时，由语法分析、C++文法、符号表、抽象语法树交互处理，交互图大致如下：

![](https://images.cnblogs.com/cnblogs_com/skynet/WindowsLiveWriter/C_D0B5/image_thumb_3.png)

这四个解析不知所做的事情大致如下：

* 由匹配文法中的函数调用，获取函数名
* 获得函数各参数表达式类型
* 语法分析器查找重载函数，符号表内部经过**重载解析**返回最佳的函数
* 语法分析器创建抽象语法树，将符号表中存储的最佳函数绑定到抽象语法树上



下面我们重点解释一下重载解析，重载解析要满足前面《3、重载函数的调用匹配》中介绍的匹配顺序和规则。重载函数解析大致可以分为三步：

- 根据函数名确定候选函数集
- 从候选函数集中选择可用函数集合
- 从可用函数集中确定最佳函数，或由于模凌两可返回错误

根据函数在**同一作用域内**所有同名的函数，并且要求是可见的（像private、protected、public、friend之类）。“同一作用域”也是在函数重载的定义中的一个限定，如果不在一个作用域，不能算是函数重载，如下面的代码：

```c++
void f(int);

void g()
{
        void f(double);
        f(1); //这里调用的是f(double)，而不是f(int)
}
```

即**内层作用域的函数会隐藏外层的同名函数**！**同样的派生类的成员函数会隐藏基类的同名函数**。这很好理解，变量的访问也是如此，如一个函数体内要访问全局的同名变量要用“::”限定。

为了查找候选函数集，一般采用**深度优选**搜索算法：

 step1：从函数调用点开始查找，逐层作用域向外查找可见的候选函数

step2： 如果上一步收集的不在用户自定义命名空间之中，则用到了using机制引入的命名空间中的候选函数，否则结束

在收集候选函数时，如果调用函数的实参类型为非结构体类型，候选函数仅包含调用点可见的函数；如果调用函数的实参类型包括类类型对象，类类型指针，类类型引用或者指向类成员的指针，候选函数为下面集合的并：

* 在调用点上可见的函数
* 在定义该类类型的名字空间或定义该类的名字空间中声明的函数
* 该类或其基类的友元函数

一个例子：

```c++
void f();
void f(int);
void f(double, double = 314);
name pace N
{
void f(char 3, char 3);
}
class{
public: operat or double() {}
};
int main()
{
    using name pace N; //using指示符
    A a;
    f(a);
    return 0;
}
```

根据上述方法，由于实参是类类型的对象，候选函数的收集分为三步：

（1）从函数调用所在的main函数作用域开始查找函数f的声明，结果未找到。到main函数作用域的外层作用域开始查找，此时在全局作用域找到3个函数f的声明，他们将放入候选集合；

（2）到using指示符所指向的命名空间N中收集f(char 3, char 3);

（3）考虑2类集合.其一为定义该类类型的名字空间或定义该类的基类的名字空间中声明的函数；其二为该类或其基类的友元函数。本例这2类集合为空。

最终候选为上述所列的4个函数f。

#### **4.2、确定可用函数**

可用的函数是指：函数参数个数匹配并且每一个参数都有隐式转换序列。

- (1)如果实参有m个参数，所有候选参数中，有且只有 m个参数；
- (2)所有候选参数中，参数个数不足m个，当前仅当参数列表中有省略号；
- (3)所有候选参数中，参数个数超过 m个，当前仅当第m + 1个参数以后都有缺省值。如果可用 
  集合为空，函数调用会失败。

这些规则在前面的《3、重载函数的调用匹配》中就有所体现了。

#### **4.3、确定最佳匹配函数**

确定可用函数之后，对可用函数集中的每一个函数，如果调用函数的实参要调用它计算优先级，最后选出优先级最高的。如对《3、重载函数的调用匹配》中介绍的匹配规则中按顺序分配权重，然后计算总的优先级，最后选出最优的函数。

#### **5、总结**

说明：在介绍函数名映射机制是基于g++编译器，不同的编译器映射有些差别。

最后留两个问题以后补充：

- 1、在C++中加号+，即可用于两个int型之间的相加、也可以用于浮点数数之间的相加、字符串之间的连接，那+算不算是操作符重载呢？换个场景C语言中加号+，即可用于两个int型之间的相加、也可以用于浮点数数之间的相加，那算不算操作符重载呢？
- 2、模板（template）的重载时怎么样的？模板函数和普通函数构成的重载，调用时又是如何匹配的呢？

##### 附录：一种C++的重载机制

![](https://images.cnblogs.com/cnblogs_com/skynet/WindowsLiveWriter/C_D0B5/image_thumb_2.png)

![](https://images.cnblogs.com/cnblogs_com/skynet/WindowsLiveWriter/C_D0B5/image_thumb_4.png)